"""
A, B = 시작값, 결과값
2를 곱하거나, 맨 뒤에 1을 넣거나
A -> B로 가는 연산의 최솟값
B의 1의자리가 1이면 직전 연산에서 1추가를 실행한것
    1을 빼주고
B의 1의자리가 1이 아니고 2의배수면 직전 연산에서 2 곱하기를 실행한것
    2를 나눠주고
B를 시작으로 A까지 가는 코드를 구성
만들 수 없는 경우를 찾는법?

"""

import sys # sys.stdin.readline()
A, B = map(int, sys.stdin.readline().split()) # A, B 입력받고
count = 0 # 결과값 초기화
while B != A: # A와 B가 같아질때까지 while문 반복
    if B%10 == 1: # B의 1의자리수가 1이면 직전 연산에서 맨 뒤에 1을 추가한 것
        B //= 10 # 10으로 나눈 몫을 반환하여 1을 제거
        count += 1 # 연산 카운트 +1
    else: # B의 1의자리수가 1이 아니면 직전연산에서 *2를 한 것
        B /= 2 # 2로 나눠주고
        count += 1 # 연산 카운트 +1
    if B < A: # 연산을 계속했는데 B가 A로 가지 못하고 A보다 작아지면
            # B에서 A를 만들 수 없으니
        count = -2 # 결과값에 1 더해질 경우를 포함해 카운트를 -2로 저장
        break # while문 종료
print(count + 1) # 출력